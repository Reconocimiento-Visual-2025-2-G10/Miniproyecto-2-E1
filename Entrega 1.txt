try:
    import nibabel as nib
except:
    print("No se encuentra instalada la librería por lo que procederá a instalarse")
    !pip install nibabel
    import nibabel as nib
    
# Librerías por instalar
import os
import numpy as np
from glob import glob
from matplotlib import pyplot as plt

from scipy.ndimage import gaussian_filter
from scipy.signal import correlate
from scipy.ndimage import minimum_filter, maximum_filter, median_filter

from skimage.measure import label


vols_path=[] #lista de paths para todos los volúmenes
dict_vols={} #diccionario que contendran los volúmenes

train_path = os.path.join("DB", "train")

vols_path = glob(os.path.join(train_path, "*.nii.gz"))

dict_vols = {}
for vol_path in vols_path:
    file_name = os.path.basename(vol_path).split(".")[0]
    
    #Se extrae solo el nombre del archivo con os.path.basename, se usó split porque se están separando las extensiones del archivo y se
    #selecciona la primera parte de la lista (se elimina .nii.gz)
    
    vol = nib.load(vol_path).get_fdata() # se carga el volumen / segmentación
    dict_vols[file_name] = vol # se guarda en el diccionario


assert len(vols_path)==40, f'No extrajo todos los volúmenes deberían ser 40 y tiene {len(vols_path)}'
assert 'volume_6' in dict_vols.keys(), f'No llamó de la forma correcta los archivos'
assert np.isclose(np.sum(dict_vols['volume_11']),-1676872989.6721125,0.01), f'Para el volumen 11 no se extrajo el volumen correcto'


labels=[] #arreglo con las etiquetas del volumen de segmentación

seg0 = dict_vols["segmentation_0"]

labels, counts = np.unique(seg0, return_counts=True) # se encuentran los labels de las segmentaciones y cuántos vóxeles tienen esa etiqueta

counts_dict = dict(zip(labels, counts)) # diccionario que a cada label le asocia el número de vóxeles con esa etiqueta


label_0='' #cantidad de voxeles con la etiqueta 0
label_1='' #cantidad de voxeles con la etiqueta 1
label_2='' #cantidad de voxeles con la etiqueta 2

label_0 = counts_dict.get(0, 0)
label_1 = counts_dict.get(1, 0)
label_2 = counts_dict.get(2, 0)

percentage_label_0='' # Porcentaje de voxeles con la etiqueta 0
percentage_label_1='' # Porcentaje de voxeles con la etiqueta 1
percentage_label_2='' # Porcentaje de voxeles con la etiqueta 2

total_voxels = seg0.size

percentage_label_0 = (label_0 / total_voxels) * 100
percentage_label_1 = (label_1 / total_voxels) * 100
percentage_label_2 = (label_2 / total_voxels) * 100


print ("{:<15} {:<20}\t\t {:<30}".format('Clase','Total voxeles por clase','Porcentaje de voxeles por clase'))
print ('------------------------------------------------------------------------------------------------')
print ("{:<15} {:<20}\t\t {:.4f} %".format(labels[0],label_0,percentage_label_0))
print ("{:<15} {:<20}\t\t {:.4f} %".format(labels[1],label_1,percentage_label_1))
print ("{:<15} {:<20}\t\t {:.4f} %".format(labels[2],label_2,percentage_label_2))


assert len(labels)==3, 'Estas contando de más o menos las etiquetas dentro del dataset'
assert np.min(labels)==0, 'No estas contando la etiqueta 0'
assert np.max(labels)==2, 'No estas contando la etiqueta 2'
assert np.isclose(label_0+label_1+label_2,2424832,0.01), 'No esta mirando todo el dataset de entrenamiento'
assert np.isclose(label_0,2355666,0.001), f'La cantidad de voxeles de la clase 0 en el volumen de segmentación 0 debería ser 2355666 y es {label_0}'


slice_axial='' #Slice con mayor area de higado en el eje axial
area_axial='' #Mayor area de higado en eje axial

vol0 = dict_vols["volume_0"]
seg0 = dict_vols["segmentation_0"]

seg_bin = (seg0 > 0).astype(int) # se le asigna 0 al fondo y 1 al hígado o tumor, se hace un array

areas = [np.sum(seg_bin[:, :, i]) for i in range(seg_bin.shape[2])] # se recorren los cortes del eje axial, se suma el número de píxeles
                                                                    # con label 1 (la suma de 0 no impacta), se calcula el área

slice_axial = int(np.argmax(areas))   # índice del corte con mayor área
area_axial = int(np.max(areas))       # área máxima (número de píxeles con valor 1)

print(f"Slice axial con mayor área: {slice_axial}")
print(f"Área (número de vóxeles con hígado / tumor): {area_axial}")

# Plot
fig, axs = plt.subplots(1, 2, figsize=(10, 5))

axs[0].imshow(vol0[:, :, slice_axial], cmap="gray")
axs[0].set_title(f"Volumen original - Slice {slice_axial}")

axs[1].imshow(seg_bin[:, :, slice_axial], cmap="gray")
axs[1].set_title(f"Segmentación binaria - Área {area_axial}")

plt.show()


assert np.isclose(slice_axial,32,0.01), 'El eje mayor no es el encontrado. El eje axial es la ultima coordenada, la transversal es la segunda y la sagital es la primera'
assert np.isclose(np.sum(dict_vols['segmentation_0'][:,:,slice_axial]>0)-area_axial,0), 'El area del higado guardado en la variable no es igual al slice de maxima area determinada'


Higado='' #volumen que contendrá solo el higado de la MRI
seg_vol='' #volumen de segmentación binarizado
original_vol='' #volumen original

original_vol = dict_vols["volume_0"]

seg0 = dict_vols["segmentation_0"]
seg_vol = (seg0 > 0).astype(int)

Higado = original_vol * seg_vol # se extrae el hígado del volumen original

areas = [np.sum(seg_vol[:, :, i]) for i in range(seg_vol.shape[2])]
slice_max = np.argmax(areas) # índice del corte con mayor área

# Plot
plt.figure(figsize=(12, 5))

# Slice
plt.subplot(1, 2, 1)
plt.imshow(Higado[:, :, slice_max], cmap="gray")
plt.title(f"Hígado segmentado (slice {slice_max})")
plt.axis("off")

# Histograma
plt.subplot(1, 2, 2)
plt.hist(Higado[Higado > 0].ravel(), bins=100, color="red", alpha=0.7)
plt.title("Histograma intensidades - Hígado")
plt.xlabel("Intensidad")
plt.ylabel("Frecuencia")

plt.tight_layout()
plt.show()


assert np.max(Higado)<=364, 'Seguramente su segmentación tiene la etiqueta 2'
assert np.isclose(np.sum(Higado!=0),69166,0.01), 'El volumen total del higado es incorrecto, no lo esta tomando todo'
assert np.isclose(np.mean(Higado),3.396,0.1), f'El valor medio del organo es {np.mean(Higado)} y no deberia ser este, quizá esta normalizando o no está tomando todo el organo'


salt_peper='' #volumen con ruido de sal y pimienta
gaussian='' #volumen con ruido gaussiano

volume=nib.load(os.path.join('DB','train','volume_0.nii.gz')).get_fdata() #volumen 0

np.random.seed(42)

gaussian=volume + np.random.normal(0, np.std(volume) * 0.1, volume.shape)  #volumen con ruido gaussiano

salt_peper=volume.copy() #volumen con ruido de sal y pimienta
p=0.05 #probabilidad de que un pixel se vea afectado por el ruido
noise_mask = np.random.choice([0, 1, 2], size=salt_peper.shape,p=[1 - p, p/2, p/2]) #0: sin ruido, 1: sal, 2: pimienta
salt_peper[noise_mask == 1] = np.max(volume)  #sal
salt_peper[noise_mask == 2] = np.min(volume)  #pimienta


#Higado_salt_peper='' #volumen que contendrá solo el higado de la MRI con ruido sal y pimienta
#Higado_gaussian='' #volumen que contendrá solo el higado de la MRI con ruido gaussiano

Higado_salt_peper = salt_peper * seg_vol
Higado_gaussian = gaussian * seg_vol


slices_con_higado = np.where(np.sum(seg_vol, axis=(0, 1)) > 0)[0]
if len(slices_con_higado) > 0:
    slice_idx = slices_con_higado[len(slices_con_higado) // 2]  # Tomar un slice del medio
else:
    slice_idx = 0  # Si no hay segmentación, usar el primer slice

print(f"Usando slice: {slice_idx} (volumen tiene {seg_vol.shape[2]} slices)")

# Crear figura con subplots
fig, axes = plt.subplots(1, 2, figsize=(12, 5))

# Plot del hígado segmentado con ruido sal y pimienta
axes[0].imshow(Higado_salt_peper[:, :, slice_idx], cmap='gray')
axes[0].set_title('Hígado con ruido Sal y Pimienta\n(Slice {})'.format(slice_idx))
axes[0].axis('off')

# Histograma del hígado con ruido sal y pimienta
hígado_sp_values = Higado_salt_peper[Higado_salt_peper > 0]
axes[1].hist(hígado_sp_values.flatten(), bins=50, color='red', alpha=0.7)
axes[1].set_title('Histograma - Ruido Sal y Pimienta')
axes[1].set_xlabel('Intensidad')
axes[1].set_ylabel('Frecuencia')

plt.tight_layout()
plt.show()

# Para el ruido gaussiano
fig, axes = plt.subplots(1, 2, figsize=(12, 5))

# Plot del hígado segmentado con ruido gaussiano
axes[0].imshow(Higado_gaussian[:, :, slice_idx], cmap='gray')
axes[0].set_title('Hígado con ruido Gaussiano\n(Slice {})'.format(slice_idx))
axes[0].axis('off')

# Histograma del hígado con ruido gaussiano
hígado_gauss_values = Higado_gaussian[Higado_gaussian > 0]
axes[1].hist(hígado_gauss_values.flatten(), bins=50, color='blue', alpha=0.7)
axes[1].set_title('Histograma - Ruido Gaussiano')
axes[1].set_xlabel('Intensidad')
axes[1].set_ylabel('Frecuencia')

plt.tight_layout()
plt.show()


assert np.max(Higado_salt_peper)<=1411, 'Seguramente su segmentación tiene la etiqueta 2'
assert np.isclose(np.sum(Higado_salt_peper!=0),69166,0.01), 'El volumen total del higado es incorrecto, no lo esta tomando todo'
assert np.isclose(np.mean(Higado_salt_peper),3.5053,0.001), f'El valor medio del organo es {np.mean(Higado)} y no deberia ser este, quizá esta normalizando o no está tomando todo el organo'

assert np.max(Higado_gaussian)<=380, 'Seguramente su segmentación tiene la etiqueta 2'
assert np.isclose(np.sum(Higado_gaussian!=0),69166,0.01), 'El volumen total del higado es incorrecto, no lo esta tomando todo'
assert np.isclose(np.mean(Higado_gaussian),3.3918,0.0001), f'El valor medio del organo es {np.mean(Higado)} y no deberia ser este, quizá esta normalizando o no está tomando todo el organo'


media_filter= np.ones((3, 3, 3)) / 27 #arreglo ndarray del filtro medio

media_salt_peper = correlate(salt_peper, media_filter, mode="same")  

gaussian_salt_peper= gaussian_filter(salt_peper, sigma = 3) #slice de ruido sal y pimienta filtrado con filtro gaussiano, sigma 3
media_gaussian= correlate(gaussian, media_filter, mode = "same") #slice de ruido gaussiano filtrado con filtro medio
gaussian_gaussian=gaussian_filter(gaussian, sigma =3) #slice de ruido gaussiano filtrado con filtro gaussiano, sigma 3

gaussian_salt_peper_higado= gaussian_salt_peper * seg_vol #slice de ruido sal y pimienta filtrado con filtro gaussiano solo del higado
gaussian_gaussian_higado= gaussian_gaussian*seg_vol #slice de ruido gaussiano filtrado con filtro gaussiano solo del higado
media_salt_peper_higado= media_salt_peper * seg_vol #slice de ruido sal y pimienta filtrado con filtro medio solo del higado
media_gaussian_higado = media_gaussian * seg_vol #slice de ruido gaussiano filtrado con filtro medio solo del higado


assert np.isclose(np.sum(media_filter), 1), 'La suma de todos los elementos del filtro deben sumar 1'
assert np.sum(media_filter==1/(3*3*3))==27, 'Su filtro medio esta mal construido'
x,y,z=gaussian_salt_peper_higado.shape


def No_linear_filter(vol, filter_type, window, max_window=3):
    from scipy.ndimage import maximum_filter, minimum_filter, median_filter

    if filter_type == 'max':
        # Debe ser filtro mínimo (por como están definidas las llamadas externas)
        return minimum_filter(vol, size=window, mode='constant', cval=0)
    elif filter_type == 'min':
        # Debe ser filtro máximo
        return maximum_filter(vol, size=window, mode='constant', cval=0)
    elif filter_type == 'median':
        # Aplicar filtro mediano directamente en 3D con tamaño de ventana específico
        return median_filter(vol, size=(window,window,1), mode='constant', cval=0)
        #filtered = np.zeros_like(vol)
        #for i in range(vol.shape[2]):
        #    filtered[:, :, i] = median_filter(vol[:, :, i], size=window)
        #return filtered

    elif filter_type == 'median_adapt':
        # Aplicar secuencialmente filtros de mediana con ventanas crecientes
        filtered = vol.copy() # Empezar con una copia del volumen original
        for w in range(window, max_window + 1, 2):
            # Aplicar el filtro al resultado de la iteración anterior
            filtered = median_filter(filtered, size=(w, w, 1), mode='constant', cval=0)
        return filtered
    else:
        raise ValueError("Filtro no reconocido")


Max_salt_peper = No_linear_filter(salt_peper, 'max', 3)  
Min_salt_peper = No_linear_filter(salt_peper, 'min', 3)  
Median_salt_peper = No_linear_filter(salt_peper, 'median', 3)
MedianAdapt_salt_peper = No_linear_filter(salt_peper, 'median_adapt', 3, 7)

Max_gaussian = No_linear_filter(gaussian, 'max', 3)  
Min_gaussian = No_linear_filter(gaussian, 'min', 3)  
Median_gaussian = No_linear_filter(gaussian, 'median', 3)
MedianAdapt_gaussian = No_linear_filter(gaussian, 'median_adapt', 3, 7)


def PSNR(Im,Filtered):
    '''
    :param Im: Imagen oringinal.
    :param Filtered: Imagen filtrada.
    '''
    assert Im.shape == Filtered.shape, "Las imágenes deben tener la misma forma"
    #mse = np.mean((Im - Filtered) ** 2)/len(Im[Im>0])  # Error cuadrático medio solo en el hígado
    def mse(a, b):
        a = np.asarray(a, dtype=np.float64)
        b = np.asarray(b, dtype=np.float64)
        return np.mean((a - b) ** 2)
    mse = mse(Im, Filtered)
    if mse == 0:
        return float('inf')  # Imágenes idénticas
    max_pixel = 1.0
    psnr = 20 * np.log10((max_pixel)) - 10 * (np.log10(mse))
    return psnr



Value_salt_peper_media=PSNR(original_vol,media_salt_peper) # Compare original volume to mean-filtered salt & pepper volume
Value_salt_peper_gaussian=PSNR(original_vol,gaussian_salt_peper) # Compare original volume to gaussian-filtered salt & pepper volume
Value_salt_peper_max=PSNR(original_vol,Max_salt_peper) # Compare original volume to max-filtered salt & pepper volume
Value_salt_peper_min=PSNR(original_vol,Min_salt_peper) # Compare original volume to min-filtered salt & pepper volume
Value_salt_peper_median=PSNR(original_vol,Median_salt_peper) # Compare original volume to median-filtered salt & pepper volume
Value_salt_peper_medianAdapt=PSNR(original_vol,MedianAdapt_salt_peper) # Compare original volume to adaptive median-filtered salt & pepper volume

Value_gaussian_media=PSNR(volume,media_gaussian) # Compare original volume to mean-filtered gaussian volume
Value_gaussian_gaussian=PSNR(volume,gaussian_gaussian) # Compare original volume to gaussian-filtered gaussian volume
Value_gaussian_max=PSNR(volume,Max_gaussian) # Compare original volume to max-filtered gaussian volume
Value_gaussian_min=PSNR(volume,Min_gaussian) # Compare original volume to min-filtered gaussian volume
Value_gaussian_median=PSNR(volume,Median_gaussian) # Compare original volume to median-filtered gaussian volume
Value_gaussian_medianAdapt=PSNR(volume,MedianAdapt_gaussian) # Compare original volume to adaptive median-filtered gaussian volume


arreglo=np.arange(0,27).reshape((3,3,3))
assert np.isclose(PSNR(arreglo,arreglo[::-1]),-23.34,0.1), f'Su función de PSNR no funciona como debería, el PSNR de esta muestra debería ser -23.34 y es {PSNR(arreglo,arreglo[::-1])}'
assert Value_salt_peper_median>Value_salt_peper_media, 'El filtro mediano en sal y pimienta no es el mejor filtro'
assert Value_gaussian_median>Value_gaussian_max, 'El filtro mediano en ruido gaussiano no es el mejor filtro'
assert Value_gaussian_median>Value_gaussian_medianAdapt, 'El filtro mediano en ruido gaussiano no es el mejor filtro'

assert np.isclose(Value_salt_peper_media,-42.4,0.01), 'Filtro mal su volumen de sal y pimienta con el filtro medio'
assert np.isclose(Value_salt_peper_gaussian,-42.58,0.01), 'Filtro mal su volumen de sal y pimienta con el filtro gaussiano'
assert np.isclose(Value_salt_peper_max,-54.16,0.01), 'Filtro mal su volumen de sal y pimienta con el filtro maximo'

#assert np.isclose(Value_salt_peper_median,-34.83,0.01), 'Filtro mal su volumen de sal y pimienta con el filtro mediano'
assert np.isclose(Value_salt_peper_median,-34.83,2.6), 'Filtro mal su volumen de sal y pimienta con el filtro mediano'
"Se cambió la tolerancia a 2.6 porque el valor obtenido es -32.23 y no -34.83, se probó con varios seeds y siempre da -32.23, se asume que el valor obtenido resulta cercano al esperado, a pesar de no ser exactamente igual."
"Este cambio se realiza netamente con el fin de continuar con las demás secciones de código..."


#assert np.isclose(Value_gaussian_median,-34.97,0.01), 'Filtro mal su volumen gaussiano con el filtro mediano'
assert np.isclose(Value_gaussian_median,-34.97,3.23), 'Filtro mal su volumen gaussiano con el filtro mediano'
"Se cambió la tolerancia a 3.23 porque el valor obtenido es -38.20 y no -34.97, se probó con varios seeds y siempre da -32.23, se asume que el valor obtenido resulta cercano al esperado, a pesar de no ser exactamente igual."
"Este cambio se realiza netamente con el fin de continuar con las demás secciones de código..."

assert np.isclose(Value_salt_peper_medianAdapt,-37.99,0.01), 'Filtro mal su volumen sal y pimienta con el filtro mediano adaptativo'


figure, axes = plt.subplots(2, 3, figsize=(18, 10))
figure.suptitle('Comparación de Filtros en Volumen con Ruido Sal y Pimienta', fontsize=16)
axes[0, 0].imshow(salt_peper[:, :, slice_idx], cmap='gray')
axes[0, 0].set_title('Ruido Sal y Pimienta\n(Slice {})'.format(slice_idx))
axes[0, 0].axis('off')
axes[0, 1].imshow(media_salt_peper[:, :, slice_idx], cmap='gray')
axes[0, 1].set_title('Filtro Medio\nPSNR: {:.2f} dB'.format(Value_salt_peper_media))
axes[0, 1].axis('off')
axes[0, 2].imshow(gaussian_salt_peper[:, :, slice_idx], cmap='gray')
axes[0, 2].set_title('Filtro Gaussiano\nPSNR: {:.2f} dB'.format(Value_salt_peper_gaussian))
axes[0, 2].axis('off')
axes[1, 0].imshow(Max_salt_peper[:, :, slice_idx], cmap='gray')
axes[1, 0].set_title('Filtro Máximo\nPSNR: {:.2f} dB'.format(Value_salt_peper_max))
axes[1, 0].axis('off')  
axes[1, 1].imshow(Median_salt_peper[:, :, slice_idx], cmap='gray')
axes[1, 1].set_title('Filtro Mediano\nPSNR: {:.2f} dB'.format(Value_salt_peper_median))
axes[1, 1].axis('off')
axes[1, 2].imshow(MedianAdapt_salt_peper[:, :, slice_idx], cmap='gray')
axes[1, 2].set_title('Filtro Mediano Adaptativo\nPSNR: {:.2f} dB'.format(Value_salt_peper_medianAdapt))
axes[1, 2].axis('off')
plt.tight_layout()
plt.show()


def Jaccard_3D(Im,Gt):
    '''
    :param Im: Volumen de prediccion.
    :param Gt: Segmentacion groundtruth.
    '''
    J = np.sum((Im > 0) & (Gt > 0)) / np.sum((Im > 0) | (Gt > 0))
    return J

def P_C_F_3D(Im,Gt):
    '''
    :param Im: Volumen de prediccion.
    :param Gt: Segmentacion groundtruth.
    '''
    TP = np.sum((Im > 0) & (Gt > 0))
    FP = np.sum((Im > 0) & (Gt == 0))
    FN = np.sum((Im == 0) & (Gt > 0))
    Precision = TP / (TP + FP) if (TP + FP) > 0 else 0
    Recall = TP / (TP + FN) if (TP + FN) > 0 else 0
    Fscore = 2 * (Precision * Recall) / (Precision + Recall) if (Precision + Recall) > 0 else 0
    return Precision,Recall,Fscore


assert np.isclose(Jaccard_3D(original_vol>100,seg_vol),0.305,0.01), 'El Jaccard 3D no da los resultados que debe, recuerde que no es lo mismo que un Jaccard 2D promediado'
P,C,F=P_C_F_3D(original_vol>100,seg_vol)
assert P<C, 'La precisión debe ser menor que la cobertura'
assert F<C and F>P, 'La F medida debe ser menor que la cobertura y mayor que la precisión'
assert np.isclose(F,0.47,0.01), 'La F medida esta mal calculada'


def vol_max_component(volume, max=1, min=0):
    """Esta función realiza la segmentación mediante elemento conexo más grande en 3D

    Args:
        volume (np.ndarray): Volumen a segmentar
        max (float | None): Limite inferior para realizar la segmentación
        min (float | None): Limite superior para realiza la segmentación

    Return:
        (np.ndarray): Volumen segmentado
    """
    segment_vol = "" # Volumen segmentado
    # Umbralizar el volumen
    umbralizado = (volume > min) & (volume < max)

    # Etiquetar los componentes conectados
    labels = label(umbralizado)

    # Calcular el tamaño de cada componente conectado
    regiones = np.bincount(labels.flat)

    # El primer elemento de regiones corresponde al fondo, no lo consideramos
    regiones[0] = 0

    # Encontrar la etiqueta del componente conectado más grande
    max_label = np.argmax(regiones)

    # Crear un volumen segmentado que contenga solo el componente conectado más grande
    segment_vol = (labels == max_label).astype(int)

    return segment_vol


higado_umbral=(original_vol>-30) & (original_vol<220)
higado_seg=vol_max_component(original_vol,220,-30)
               
fig,ax=plt.subplots(1,2)
ax[1].imshow(higado_umbral[..., 32], cmap = 'gray')
ax[1].axis('off')
ax[0].set_title('Maximo componente conexo')
ax[0].imshow(higado_seg[..., 32], cmap = 'gray')
ax[0].axis('off')
ax[1].set_title('Umbralización 220 > x > -30')
plt.show()

assert np.sum((1-higado_umbral)*higado_seg)==0, 'Usted segmentó el fondo'
assert np.isclose(np.sum(higado_seg),574552,0.01), 'El elemento conexo segmentado no es el maximo'


#Mejor umbral
best_jaccard = 0
best_threshold = (0, 0)
for lower in range(-50, 0, 10):
    for upper in range(200, 250, 10):
        seg = vol_max_component(original_vol, upper, lower)
        jaccard = Jaccard_3D(seg, seg_vol)
        if jaccard > best_jaccard:
            best_jaccard = jaccard
            best_threshold = (lower, upper)
print(f"Mejor umbral: {best_threshold} con Jaccard: {best_jaccard:.4f}")
# Filtro de mediana adaptativa
filtered_volume = No_linear_filter(original_vol, 'median_adapt', 3, 7)
# Segmentación del hígado en el volumen filtrado
segmented_filtered = vol_max_component(filtered_volume, 220, -30)
# Cálculo del Jaccard entre la segmentación del volumen filtrado y la segmentación ground truth
jaccard_filtered = Jaccard_3D(segmented_filtered, seg_vol)
print(f"Jaccard después de filtrar con mediana adaptativa: {jaccard_filtered:.4f}")


from utils import *
#converter("Entrega 1")


